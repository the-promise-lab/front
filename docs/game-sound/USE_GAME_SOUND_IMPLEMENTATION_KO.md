# useGameSound 구현 노트

이 문서는 공유 오디오 레이어의 구조와 동작 방식을 설명합니다. 새로 합류한 개발자가 기능을 확장하거나 버그를 추적할 때 참고할 수 있도록 설계 의도와 핵심 메커니즘을 정리했습니다.

## 전체 아키텍처 개요

- **싱글턴 매니저**: `AudioManager`는 하나의 `AudioContext`, 마스터 게인, 채널별 게인 노드를 캡슐화합니다. `AudioManager.i` 게터를 통해 지연 초기화되며, 브라우저 환경 여부를 확인하고 최초 사용자 제스처에서 자동으로 재생 잠금을 해제합니다.
- **명령형 훅**: `useGameSound`는 매니저를 메모이즈한 뒤 외부 상태 구독 없이 명령형 헬퍼만 노출합니다. 컴포넌트는 훅에서 제공하는 함수를 호출해 재생을 제어하지만, 상태 변화를 감지해 리렌더링할 필요는 없습니다.

## AudioManager 구성

매니저는 장기적으로 살아 있는 모든 오디오 리소스를 소유하여 채널 동작을 결정적으로 유지합니다.

- **채널 레지스트리**: `Map<ChannelName, ChannelState>`가 각 채널의 Web Audio `GainNode`, 최신 볼륨, 음소거 여부를 추적합니다. `applyChannelState`는 이 논리 값을 덕킹을 고려한 게인 램프로 변환합니다.
- **캐싱 레이어**: `bufferCache`와 `loadingBuffers`는 SFX의 fetch/디코딩 작업을 중복 없이 처리합니다. 미디어 재생 인스턴스는 URL별 `mediaPlaybacks`에 모아두어 BGM 크로스페이드 시 기존 엘리먼트를 페이드아웃하고 새 엘리먼트를 준비할 수 있습니다.
- **자동 재생 해제**: `setupAutoplayUnlock`은 iOS Safari와 데스크톱 Chrome에서 중단된 `AudioContext`를 재개하기 위해 필요한 제스처 이벤트 리스너를 등록합니다.
- **명령 표면**: 공개 메서드(`preload`, `play`, `crossfadeBgm`, `setVolume`, `mute`)는 모두 내부 헬퍼를 경유하여 상태 전이가 한곳에 모이도록 합니다. 예컨대 `setVolume`은 채널 볼륨 상태를 갱신한 뒤 `applyChannelState`를 호출해 게인 램프를 예약합니다.
- **라이프사이클 관리**: 두 재생 경로 모두 `onended`/`pause` 리스너를 부착하고, `cleanup`/`stop` 헬퍼에서 타이머·노드·카운터를 정리합니다. 이를 통해 Web Audio 그래프 누수나, 호출자가 수동으로 정지했을 때 덕킹 카운터가 남는 문제를 방지합니다.

## 채널 상태 & 볼륨 흐름

각 채널은 Web Audio `GainNode`, 마지막으로 설정한 볼륨, 음소거 플래그를 포함하는 `ChannelState`를 유지합니다. `setVolume`과 `mute`만이 상태를 변경하며, 덕킹이 활성화된 동안에는 BGM 목표 게인이 `duckingAttenuation` 값으로 곱해집니다. 덕킹의 시작과 종료에는 선형 램프를 사용해 팝 노이즈를 방지합니다.

## 버퍼 재생 경로

짧은 효과음과 저지연 사운드는 `playViaBuffer`를 통해 재생됩니다.

1. `preload`가 URL을 CORS 모드로 요청하고, `decodeAudioData`로 디코딩한 뒤 `AudioBuffer`를 메모리에 캐시합니다.
2. 재생 시마다 새로운 `AudioBufferSourceNode`와 전용 게인 노드를 생성해, 동시에 재생되는 사운드가 서로 다른 페이드 곡선을 가질 수 있도록 합니다.
3. 선택 기능: `detune`으로 피치를 조정하고, `at`으로 시작 시점을 예약하며, `fadeInMs`로 볼륨 상승을 제어합니다. `ducking` 옵션이 true인 경우 참조 카운터를 증가시켜, 겹치는 SFX가 모두 끝날 때까지 BGM 감쇠가 유지되도록 합니다.
4. 반환된 핸들은 게인을 0까지 램프 다운한 뒤 소스를 정지시키는 방식으로 페이드아웃을 지원합니다.

## 미디어 엘리먼트 재생 경로

장시간 BGM은 미디어 엘리먼트 경로를 사용합니다.

1. `playViaMediaElement`가 새로운 `<audio>` 엘리먼트를 생성하고 `createMediaElementSource`로 감싸 채널 게인에 연결합니다.
2. URL별로 하나의 활성 재생만 유지합니다. 동일 URL을 다시 재생하면 기존 인스턴스를 페이드아웃한 뒤 새 인스턴스를 시작해 씬 전환 시 중첩 루프를 방지합니다.
3. 버퍼 경로와 동일한 페이드인/페이드아웃 전략을 사용하지만, 샘플 정확도를 유지하기 위해 Web Audio 게인을 조절하고 엘리먼트 볼륨은 항상 1로 유지합니다.
4. 정리 단계에서 타이머와 이벤트 리스너를 해제하고, 노드를 분리해 Web Audio 그래프 누수를 방지합니다.

## 덕킹 동작

`sfx` 채널에서 `ducking: true`로 재생이 시작되면 카운터를 증가시키고, 최초 활성화 시 BGM 채널 게인을 `duckingAttenuation`까지 선형 페이드합니다. 재생이 끝날 때마다 카운터를 감소시키며, 0이 되면 채널 상태에 저장된 볼륨으로 복귀하는 램프를 예약합니다. 이렇게 하면 겹치는 SFX가 있는 동안에도 믹스가 안정적으로 유지됩니다.

## 크로스페이드

`crossfadeBgm`은 이전 BGM URL(있다면)과 새 URL을 받아, 지정한 기간 동안 이전 트랙을 페이드아웃하고 동시에 새 트랙을 동일 기간 페이드인합니다. 새 트랙의 `PlayHandle`을 반환하므로 호출 측에서 필요 시 추가 제어를 계속할 수 있습니다.

## 훅 계약

`useGameSound`는 안정적인 헬퍼 집합을 반환합니다. 훅이 싱글턴 매니저만 메모이즈하기 때문에, 구조 분해 할당을 하더라도 참조가 변하지 않습니다. `preload`는 단일 URL 또는 배열을 받아 내부 `preload`를 호출하고 모든 버퍼가 준비되면 완료됩니다. 고급 오디오 구성을 위해 원본 `AudioContext`를 그대로 노출합니다.

## 오류 처리 & 복원력

- fetch/디코딩 실패 시 진행 중인 프로미스 캐시를 정리하고 오류를 재던져, 캐시가 고착되는 것을 막습니다.
- 미디어 엘리먼트 재생을 try/catch로 감싸 노드를 분리한 뒤 호출자에게 예외를 전달합니다.
- 자동재생 해제는 포인터/터치/키 입력을 감지해 `resume`을 시도하므로, 소비자 코드에서 별도 처리가 필요 없습니다.

## 확장 지침

- 새로운 채널이 필요하면 `ChannelName`을 확장하고 생성자에서 게인 노드를 초기화하세요.
- 덕킹 정책을 변경하려면 `duckingAttenuation` 값을 조정하거나 외부에서 설정할 수 있는 메서드를 노출하세요.
- 사용자 설정 기능은 별도 도메인 모듈로 추상화하고, 이 공유 레이어는 저수준 오디오 오케스트레이션에 집중하도록 유지하는 것이 좋습니다.
